import torch

class CyclicPermutationGroup(object):
    """
    Cyclic permutation group, a subgroup of S_n, generated by the 
    permutation (123...p), i.e. where only cyclic shifts of the first p 
    elements occur.
    """
    def __init__(self, n, p, device):
        self.n = n
        self.p = p
        self.cache = [None for i in range(self.p)]
        self.device = device
    
    def __len__(self):
        return self.p

    def get_element(self, i):
        """
        Returns g = a^i where a = (12...p) is the generator of the group
        """
        if self.cache[i] is not None:
            return self.cache[i]
        g = torch.zeros((self.n, self.n)).to(self.device)
        for j in range(self.p):
            g[(j + i) % self.p, j] = 1
        for j in range(self.p, self.n):
            g[j, j] = 1
        if self.cache[i] is None:
            self.cache[i] = g
        return g

    def get_inverse(self, i):
        """
        Returns inverse of g=a^i, i.e. a^(p - i)
        """
        return self.get_element((self.p - i) % self.p)
    
    def act(self, i, x):
        """
        Act on x with g = a^i
        """
        g = self.get_element(i).unsqueeze(0).unsqueeze(0).repeat(x.shape[0], 
            x.shape[1], 1, 1)
        g = self.fix_shape(g, x)
        return torch.matmul(g, x)
    
    def act_inverse(self, i, x):
        """
        Act on x with g = a^{-i}
        """
        g = self.get_inverse(i).unsqueeze(0).unsqueeze(0).repeat(x.shape[0], 
            x.shape[1], 1, 1)
        g = self.fix_shape(g, x)
        return torch.matmul(g, x)
    
    def fix_shape(self, g, x):
        """
        Ensures tensors are correct size for multiplication.
        """
        if x.shape[2] < self.n and x.shape[2] >= self.p:
            g = g[:, :, :x.shape[2],: x.shape[2]]
        elif x.shape[2] > self.n:
            new_g = torch.zeros((g.shape[0], g.shape[1], x.shape[2], 
                x.shape[2])).to(self.device)
            new_g[:, :, :g.shape[2], :g.shape[3]] = g
            new_g[:, :, g.shape[2]:, g.shape[3]:] = torch.eye(
                x.shape[2] - self.n)
            g = new_g
        return g
